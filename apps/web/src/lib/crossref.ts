/**
 * Tokenizer for Indonesian legal cross-references in pasal content text.
 *
 * Splits a string into alternating plain-text and link tokens without
 * modifying the original text. Pure function — no React, no side effects.
 */

export type Token =
  | { type: "text"; value: string }
  | { type: "pasal"; value: string; pasalNumber: string; href: string }
  | { type: "uu"; value: string; href: string };

/**
 * Regex that matches Indonesian legal cross-references.
 *
 * Group 1 (PASAL_RE): Pasal references, optionally with ayat.
 *   - "Pasal 5", "pasal 5A", "Pasal 12 ayat (2)", "Pasal 1 Ayat (a)"
 *
 * Group 2 (UU_RE): Full regulation citations with number and year.
 *   - "Undang-Undang Nomor 13 Tahun 2003" / "UNDANG-UNDANG Nomor 13 Tahun 2003"
 *   - "Peraturan Pemerintah Nomor 74 Tahun 2008"
 *   - "Peraturan Presiden Nomor 12 Tahun 2010"
 *   - "Perppu Nomor 1 Tahun 2022" / "Perpu Nomor 1 Tahun 2022"
 *
 * The `i` flag makes the entire regex case-insensitive, covering all-caps
 * variants (UNDANG-UNDANG, PASAL) common in scanned Indonesian PDFs.
 */
const CROSSREF_RE = new RegExp(
  // Group 1: Pasal N [ayat (X)]
  "((?:Pasal)\\s+\\d+[A-Za-z]?(?:\\s+(?:Ayat)\\s+\\([0-9a-zA-Z]+\\))?)" +
    "|" +
    // Group 2: Full regulation citation
    "((?:Undang-Undang|Peraturan\\s+Pemerintah|Peraturan\\s+Presiden|Peraturan\\s+Daerah|Perppu|Perpu)" +
    "(?:\\s+Nomor)?\\s+\\d+\\s+Tahun\\s+\\d{4})",
  "gi"
);

/**
 * Mapping from citation keyword to slug type prefix.
 * Used to build the lookup key from a UU citation string.
 */
const TYPE_PREFIX_MAP: [RegExp, string][] = [
  [/^Undang-Undang/i, "uu"],
  [/^Peraturan\s+Pemerintah/i, "pp"],
  [/^Peraturan\s+Presiden/i, "perpres"],
  [/^Peraturan\s+Daerah/i, "perda"],
  [/^Per(?:p)?pu/i, "perppu"],
];

/**
 * Extracts number and year from a citation string like
 * "Undang-Undang Nomor 13 Tahun 2003" → { number: "13", year: "2003" }
 */
function extractNumberYear(citation: string): { number: string; year: string } | null {
  const m = citation.match(/(\d+)\s+Tahun\s+(\d{4})/i);
  if (!m) return null;
  return { number: m[1], year: m[2] };
}

/**
 * Builds a slug key like "uu-13-2003" from a citation string.
 * Matches the format generated by the DB trigger (generate_work_slug()):
 *   {type_prefix}-{number}-{year}
 * e.g. "Undang-Undang Nomor 13 Tahun 2003" → "uu-13-2003"
 * Returns null if the citation cannot be mapped.
 */
function citationToSlugKey(citation: string): string | null {
  let typePrefix: string | null = null;
  for (const [re, prefix] of TYPE_PREFIX_MAP) {
    if (re.test(citation)) {
      typePrefix = prefix;
      break;
    }
  }
  if (!typePrefix) return null;

  const parsed = extractNumberYear(citation);
  if (!parsed) return null;

  return `${typePrefix}-${parsed.number}-${parsed.year}`;
}

/**
 * Tokenizes `text` into an array of plain-text and link tokens.
 *
 * @param text        The raw content_text of a document node
 * @param worksLookup Map of slug key → absolute pathname, e.g. { "uu-13-2003": "/peraturan/uu/uu-13-2003" }
 */
export function tokenize(text: string, worksLookup: Record<string, string>): Token[] {
  if (!text) return [{ type: "text", value: "" }];

  const tokens: Token[] = [];
  let lastIndex = 0;

  // Reset regex state (global flag retains lastIndex between calls)
  CROSSREF_RE.lastIndex = 0;

  let match: RegExpExecArray | null;
  while ((match = CROSSREF_RE.exec(text)) !== null) {
    const [fullMatch, pasalMatch, uuMatch] = match;
    const matchStart = match.index;

    // Append preceding plain text
    if (matchStart > lastIndex) {
      tokens.push({ type: "text", value: text.slice(lastIndex, matchStart) });
    }

    if (pasalMatch) {
      // Extract the pasal number from e.g. "Pasal 5A Ayat (2)" / "PASAL 5" → "5A"
      const numMatch = pasalMatch.match(/(?:Pasal)\s+(\d+[A-Za-z]?)/i);
      const pasalNumber = numMatch ? numMatch[1] : pasalMatch;
      tokens.push({
        type: "pasal",
        value: pasalMatch,
        pasalNumber,
        href: `#pasal-${pasalNumber}`,
      });
    } else if (uuMatch) {
      const slugKey = citationToSlugKey(uuMatch);
      if (slugKey && worksLookup[slugKey]) {
        tokens.push({
          type: "uu",
          value: uuMatch,
          href: worksLookup[slugKey],
        });
      } else {
        // Unresolvable — emit as plain text, do not produce a broken link
        tokens.push({ type: "text", value: uuMatch });
      }
    }

    lastIndex = matchStart + fullMatch.length;
  }

  // Append remaining plain text
  if (lastIndex < text.length) {
    tokens.push({ type: "text", value: text.slice(lastIndex) });
  }

  return tokens;
}
